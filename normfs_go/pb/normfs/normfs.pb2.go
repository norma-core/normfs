// Code generated by gremlin. DO NOT EDIT.
// source: normfs.proto

package normfs

import gremlin "github.com/norma-core/norma-core/shared/gremlin_go"

type OffsetType int32

const (
	OffsetType_OT_ABSOLUTE OffsetType = 0
	OffsetType_OT_SHIFT_FROM_TAIL OffsetType = 1
)

func (e OffsetType) String() string {
	switch e {
	case OffsetType_OT_ABSOLUTE:
		return "OT_ABSOLUTE"
	case OffsetType_OT_SHIFT_FROM_TAIL:
		return "OT_SHIFT_FROM_TAIL"
	default:
		return ""
	}
}

type WriteResponse_Result int32

const (
	WriteResponse_WR_DONE WriteResponse_Result = 0
	WriteResponse_WR_SERVER_ERROR WriteResponse_Result = 1
)

func (e WriteResponse_Result) String() string {
	switch e {
	case WriteResponse_WR_DONE:
		return "WR_DONE"
	case WriteResponse_WR_SERVER_ERROR:
		return "WR_SERVER_ERROR"
	default:
		return ""
	}
}

type ReadResponse_Result int32

const (
	ReadResponse_RR_START ReadResponse_Result = 0
	ReadResponse_RR_ENTRY ReadResponse_Result = 1
	ReadResponse_RR_END ReadResponse_Result = 2
	ReadResponse_RR_QUEUE_NOT_FOUND ReadResponse_Result = 3
	ReadResponse_RR_NOT_FOUND ReadResponse_Result = 4
	ReadResponse_RR_SERVER_ERROR ReadResponse_Result = 5
)

func (e ReadResponse_Result) String() string {
	switch e {
	case ReadResponse_RR_START:
		return "RR_START"
	case ReadResponse_RR_ENTRY:
		return "RR_ENTRY"
	case ReadResponse_RR_END:
		return "RR_END"
	case ReadResponse_RR_QUEUE_NOT_FOUND:
		return "RR_QUEUE_NOT_FOUND"
	case ReadResponse_RR_NOT_FOUND:
		return "RR_NOT_FOUND"
	case ReadResponse_RR_SERVER_ERROR:
		return "RR_SERVER_ERROR"
	default:
		return ""
	}
}

type ReadResponse_DataSource int32

const (
	ReadResponse_DS_NONE ReadResponse_DataSource = 0
	ReadResponse_DS_CLOUD ReadResponse_DataSource = 1
	ReadResponse_DS_DISK_STORE ReadResponse_DataSource = 2
	ReadResponse_DS_DISK_WAL ReadResponse_DataSource = 3
	ReadResponse_DS_MEMORY ReadResponse_DataSource = 4
)

func (e ReadResponse_DataSource) String() string {
	switch e {
	case ReadResponse_DS_NONE:
		return "DS_NONE"
	case ReadResponse_DS_CLOUD:
		return "DS_CLOUD"
	case ReadResponse_DS_DISK_STORE:
		return "DS_DISK_STORE"
	case ReadResponse_DS_DISK_WAL:
		return "DS_DISK_WAL"
	case ReadResponse_DS_MEMORY:
		return "DS_MEMORY"
	default:
		return ""
	}
}

const (
	wireClientRequest_Setup gremlin.ProtoWireNumber = 1
	wireClientRequest_Ping gremlin.ProtoWireNumber = 2
	wireClientRequest_Write gremlin.ProtoWireNumber = 10
	wireClientRequest_Read gremlin.ProtoWireNumber = 11
)

type ClientRequestReader struct {
	buf *gremlin.Reader

	dataSetup     *SetupRequestReader
	dataPing     *PingRequestReader
	dataWrite     *WriteRequestReader
	dataRead     *ReadRequestReader

	offsetSetup   int
	offsetPing   int
	offsetWrite   int
	offsetRead   int

	parsedSetup   bool
	parsedPing   bool
	parsedWrite   bool
	parsedRead   bool
}

func NewClientRequestReader() *ClientRequestReader {
	return &ClientRequestReader{}
}

func (m *ClientRequestReader) GetSetup() *SetupRequestReader {
	if m == nil {
		return nil
	}
	return m.readSetup()
}

func (m *ClientRequestReader) readSetup() *SetupRequestReader {
	if m.parsedSetup {
		return m.dataSetup
	}
	wOffset := m.offsetSetup
	
	var entry *SetupRequestReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewSetupRequestReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataSetup = entry
	m.parsedSetup = true
	return entry
}

func (m *ClientRequestReader) GetPing() *PingRequestReader {
	if m == nil {
		return nil
	}
	return m.readPing()
}

func (m *ClientRequestReader) readPing() *PingRequestReader {
	if m.parsedPing {
		return m.dataPing
	}
	wOffset := m.offsetPing
	
	var entry *PingRequestReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewPingRequestReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataPing = entry
	m.parsedPing = true
	return entry
}

func (m *ClientRequestReader) GetWrite() *WriteRequestReader {
	if m == nil {
		return nil
	}
	return m.readWrite()
}

func (m *ClientRequestReader) readWrite() *WriteRequestReader {
	if m.parsedWrite {
		return m.dataWrite
	}
	wOffset := m.offsetWrite
	
	var entry *WriteRequestReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewWriteRequestReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataWrite = entry
	m.parsedWrite = true
	return entry
}

func (m *ClientRequestReader) GetRead() *ReadRequestReader {
	if m == nil {
		return nil
	}
	return m.readRead()
}

func (m *ClientRequestReader) readRead() *ReadRequestReader {
	if m.parsedRead {
		return m.dataRead
	}
	wOffset := m.offsetRead
	
	var entry *ReadRequestReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewReadRequestReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataRead = entry
	m.parsedRead = true
	return entry
}

func (m *ClientRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireClientRequest_Setup:
			m.offsetSetup = offset
		case wireClientRequest_Ping:
			m.offsetPing = offset
		case wireClientRequest_Write:
			m.offsetWrite = offset
		case wireClientRequest_Read:
			m.offsetRead = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ClientRequestReader) ToStruct() *ClientRequest {
	if m == nil {
		return nil
	}
	res := &ClientRequest{}

	{
		var data = m.GetSetup()
		var structData *SetupRequest
		if data != nil {
			structData = data.ToStruct()
		}
		res.Setup = structData
	}

	{
		var data = m.GetPing()
		var structData *PingRequest
		if data != nil {
			structData = data.ToStruct()
		}
		res.Ping = structData
	}

	{
		var data = m.GetWrite()
		var structData *WriteRequest
		if data != nil {
			structData = data.ToStruct()
		}
		res.Write = structData
	}

	{
		var data = m.GetRead()
		var structData *ReadRequest
		if data != nil {
			structData = data.ToStruct()
		}
		res.Read = structData
	}

	return res
}

func (s *ClientRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ClientRequest struct {
	Setup	*SetupRequest	`json:"setup,omitempty"`
	Ping	*PingRequest	`json:"ping,omitempty"`
	Write	*WriteRequest	`json:"write,omitempty"`
	Read	*ReadRequest	`json:"read,omitempty"`
}

func (s *ClientRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ClientRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Setup != nil {
		structSize := s.Setup.XXX_PbContentSize()
		res.AppendBytesTag(wireClientRequest_Setup, structSize)
		s.Setup.MarshalTo(res)
	}
	if s.Ping != nil {
		structSize := s.Ping.XXX_PbContentSize()
		res.AppendBytesTag(wireClientRequest_Ping, structSize)
		s.Ping.MarshalTo(res)
	}
	if s.Write != nil {
		structSize := s.Write.XXX_PbContentSize()
		res.AppendBytesTag(wireClientRequest_Write, structSize)
		s.Write.MarshalTo(res)
	}
	if s.Read != nil {
		structSize := s.Read.XXX_PbContentSize()
		res.AppendBytesTag(wireClientRequest_Read, structSize)
		s.Read.MarshalTo(res)
	}
}

func (s *ClientRequest) Copy() *ClientRequest {
	if s == nil {
		return nil
	}
	res := &ClientRequest{}
	if s.Setup != nil {
		res.Setup = s.Setup.Copy()
	}
	if s.Ping != nil {
		res.Ping = s.Ping.Copy()
	}
	if s.Write != nil {
		res.Write = s.Write.Copy()
	}
	if s.Read != nil {
		res.Read = s.Read.Copy()
	}

	return res
}

func (s *ClientRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Setup != nil {
		var entrySize = 0
		entrySize = s.Setup.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireClientRequest_Setup)
		
		size += entrySize
	}

	if s.Ping != nil {
		var entrySize = 0
		entrySize = s.Ping.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireClientRequest_Ping)
		
		size += entrySize
	}

	if s.Write != nil {
		var entrySize = 0
		entrySize = s.Write.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireClientRequest_Write)
		
		size += entrySize
	}

	if s.Read != nil {
		var entrySize = 0
		entrySize = s.Read.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireClientRequest_Read)
		
		size += entrySize
	}

	return size
}

const (
	wireServerResponse_Setup gremlin.ProtoWireNumber = 1
	wireServerResponse_Ping gremlin.ProtoWireNumber = 2
	wireServerResponse_Write gremlin.ProtoWireNumber = 10
	wireServerResponse_Read gremlin.ProtoWireNumber = 11
)

type ServerResponseReader struct {
	buf *gremlin.Reader

	dataSetup     *SetupResponseReader
	dataPing     *PingResponseReader
	dataWrite     *WriteResponseReader
	dataRead     *ReadResponseReader

	offsetSetup   int
	offsetPing   int
	offsetWrite   int
	offsetRead   int

	parsedSetup   bool
	parsedPing   bool
	parsedWrite   bool
	parsedRead   bool
}

func NewServerResponseReader() *ServerResponseReader {
	return &ServerResponseReader{}
}

func (m *ServerResponseReader) GetSetup() *SetupResponseReader {
	if m == nil {
		return nil
	}
	return m.readSetup()
}

func (m *ServerResponseReader) readSetup() *SetupResponseReader {
	if m.parsedSetup {
		return m.dataSetup
	}
	wOffset := m.offsetSetup
	
	var entry *SetupResponseReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewSetupResponseReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataSetup = entry
	m.parsedSetup = true
	return entry
}

func (m *ServerResponseReader) GetPing() *PingResponseReader {
	if m == nil {
		return nil
	}
	return m.readPing()
}

func (m *ServerResponseReader) readPing() *PingResponseReader {
	if m.parsedPing {
		return m.dataPing
	}
	wOffset := m.offsetPing
	
	var entry *PingResponseReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewPingResponseReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataPing = entry
	m.parsedPing = true
	return entry
}

func (m *ServerResponseReader) GetWrite() *WriteResponseReader {
	if m == nil {
		return nil
	}
	return m.readWrite()
}

func (m *ServerResponseReader) readWrite() *WriteResponseReader {
	if m.parsedWrite {
		return m.dataWrite
	}
	wOffset := m.offsetWrite
	
	var entry *WriteResponseReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewWriteResponseReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataWrite = entry
	m.parsedWrite = true
	return entry
}

func (m *ServerResponseReader) GetRead() *ReadResponseReader {
	if m == nil {
		return nil
	}
	return m.readRead()
}

func (m *ServerResponseReader) readRead() *ReadResponseReader {
	if m.parsedRead {
		return m.dataRead
	}
	wOffset := m.offsetRead
	
	var entry *ReadResponseReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewReadResponseReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataRead = entry
	m.parsedRead = true
	return entry
}

func (m *ServerResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireServerResponse_Setup:
			m.offsetSetup = offset
		case wireServerResponse_Ping:
			m.offsetPing = offset
		case wireServerResponse_Write:
			m.offsetWrite = offset
		case wireServerResponse_Read:
			m.offsetRead = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ServerResponseReader) ToStruct() *ServerResponse {
	if m == nil {
		return nil
	}
	res := &ServerResponse{}

	{
		var data = m.GetSetup()
		var structData *SetupResponse
		if data != nil {
			structData = data.ToStruct()
		}
		res.Setup = structData
	}

	{
		var data = m.GetPing()
		var structData *PingResponse
		if data != nil {
			structData = data.ToStruct()
		}
		res.Ping = structData
	}

	{
		var data = m.GetWrite()
		var structData *WriteResponse
		if data != nil {
			structData = data.ToStruct()
		}
		res.Write = structData
	}

	{
		var data = m.GetRead()
		var structData *ReadResponse
		if data != nil {
			structData = data.ToStruct()
		}
		res.Read = structData
	}

	return res
}

func (s *ServerResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ServerResponse struct {
	Setup	*SetupResponse	`json:"setup,omitempty"`
	Ping	*PingResponse	`json:"ping,omitempty"`
	Write	*WriteResponse	`json:"write,omitempty"`
	Read	*ReadResponse	`json:"read,omitempty"`
}

func (s *ServerResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ServerResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Setup != nil {
		structSize := s.Setup.XXX_PbContentSize()
		res.AppendBytesTag(wireServerResponse_Setup, structSize)
		s.Setup.MarshalTo(res)
	}
	if s.Ping != nil {
		structSize := s.Ping.XXX_PbContentSize()
		res.AppendBytesTag(wireServerResponse_Ping, structSize)
		s.Ping.MarshalTo(res)
	}
	if s.Write != nil {
		structSize := s.Write.XXX_PbContentSize()
		res.AppendBytesTag(wireServerResponse_Write, structSize)
		s.Write.MarshalTo(res)
	}
	if s.Read != nil {
		structSize := s.Read.XXX_PbContentSize()
		res.AppendBytesTag(wireServerResponse_Read, structSize)
		s.Read.MarshalTo(res)
	}
}

func (s *ServerResponse) Copy() *ServerResponse {
	if s == nil {
		return nil
	}
	res := &ServerResponse{}
	if s.Setup != nil {
		res.Setup = s.Setup.Copy()
	}
	if s.Ping != nil {
		res.Ping = s.Ping.Copy()
	}
	if s.Write != nil {
		res.Write = s.Write.Copy()
	}
	if s.Read != nil {
		res.Read = s.Read.Copy()
	}

	return res
}

func (s *ServerResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Setup != nil {
		var entrySize = 0
		entrySize = s.Setup.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireServerResponse_Setup)
		
		size += entrySize
	}

	if s.Ping != nil {
		var entrySize = 0
		entrySize = s.Ping.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireServerResponse_Ping)
		
		size += entrySize
	}

	if s.Write != nil {
		var entrySize = 0
		entrySize = s.Write.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireServerResponse_Write)
		
		size += entrySize
	}

	if s.Read != nil {
		var entrySize = 0
		entrySize = s.Read.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireServerResponse_Read)
		
		size += entrySize
	}

	return size
}

const (
	wireId_Raw gremlin.ProtoWireNumber = 1
)

type IdReader struct {
	buf *gremlin.Reader

	dataRaw     []byte

	offsetRaw   int

	parsedRaw   bool
}

func NewIdReader() *IdReader {
	return &IdReader{}
}

func (m *IdReader) GetRaw() []byte {
	if m == nil {
		return nil
	}
	return m.readRaw()
}

func (m *IdReader) readRaw() []byte {
	if m.parsedRaw {
		return m.dataRaw
	}
	wOffset := m.offsetRaw
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataRaw = entry
	m.parsedRaw = true
	return entry
}

func (m *IdReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireId_Raw:
			m.offsetRaw = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *IdReader) ToStruct() *Id {
	if m == nil {
		return nil
	}
	res := &Id{}
	res.Raw = m.GetRaw()

	return res
}

func (s *IdReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Id struct {
	Raw	[]byte	`json:"raw,omitempty"`
}

func (s *Id) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Id) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if len(s.Raw) != 0 {
		res.AppendBytes(wireId_Raw, s.Raw)
	}
}

func (s *Id) Copy() *Id {
	if s == nil {
		return nil
	}
	res := &Id{}
	res.Raw = s.Raw

	return res
}

func (s *Id) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if len(s.Raw) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.Raw)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireId_Raw)
		size += entrySize
	}

	return size
}

const (
	wireOffset_Id gremlin.ProtoWireNumber = 1
	wireOffset_Type gremlin.ProtoWireNumber = 2
)

type OffsetReader struct {
	buf *gremlin.Reader

	dataId     *IdReader
	dataType     OffsetType

	offsetId   int
	offsetType   int

	parsedId   bool
	parsedType   bool
}

func NewOffsetReader() *OffsetReader {
	return &OffsetReader{}
}

func (m *OffsetReader) GetId() *IdReader {
	if m == nil {
		return nil
	}
	return m.readId()
}

func (m *OffsetReader) readId() *IdReader {
	if m.parsedId {
		return m.dataId
	}
	wOffset := m.offsetId
	
	var entry *IdReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewIdReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataId = entry
	m.parsedId = true
	return entry
}

func (m *OffsetReader) GetType() OffsetType {
	if m == nil {
		return 0
	}
	return m.readType()
}

func (m *OffsetReader) readType() OffsetType {
	if m.parsedType {
		return m.dataType
	}
	wOffset := m.offsetType
	
	var entry OffsetType
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = OffsetType(rawEntry)
	}
	
	m.dataType = entry
	m.parsedType = true
	return entry
}

func (m *OffsetReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireOffset_Id:
			m.offsetId = offset
		case wireOffset_Type:
			m.offsetType = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *OffsetReader) ToStruct() *Offset {
	if m == nil {
		return nil
	}
	res := &Offset{}

	{
		var data = m.GetId()
		var structData *Id
		if data != nil {
			structData = data.ToStruct()
		}
		res.Id = structData
	}
	res.Type = m.GetType()

	return res
}

func (s *OffsetReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type Offset struct {
	Id	*Id	`json:"id,omitempty"`
	Type	OffsetType	`json:"type,omitempty"`
}

func (s *Offset) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *Offset) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Id != nil {
		structSize := s.Id.XXX_PbContentSize()
		res.AppendBytesTag(wireOffset_Id, structSize)
		s.Id.MarshalTo(res)
	}
	if s.Type != 0 {
		res.AppendInt32(wireOffset_Type, int32(s.Type))
	}
}

func (s *Offset) Copy() *Offset {
	if s == nil {
		return nil
	}
	res := &Offset{}
	if s.Id != nil {
		res.Id = s.Id.Copy()
	}
	res.Type = s.Type

	return res
}

func (s *Offset) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Id != nil {
		var entrySize = 0
		entrySize = s.Id.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireOffset_Id)
		
		size += entrySize
	}

	if s.Type != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireOffset_Type) + gremlin.SizeInt32(int32(s.Type))
		size += entrySize
	}

	return size
}

const (
	wireSetupRequest_Version gremlin.ProtoWireNumber = 1
)

type SetupRequestReader struct {
	buf *gremlin.Reader

	dataVersion     uint64

	offsetVersion   int

	parsedVersion   bool
}

func NewSetupRequestReader() *SetupRequestReader {
	return &SetupRequestReader{}
}

func (m *SetupRequestReader) GetVersion() uint64 {
	if m == nil {
		return 0
	}
	return m.readVersion()
}

func (m *SetupRequestReader) readVersion() uint64 {
	if m.parsedVersion {
		return m.dataVersion
	}
	wOffset := m.offsetVersion
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataVersion = entry
	m.parsedVersion = true
	return entry
}

func (m *SetupRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireSetupRequest_Version:
			m.offsetVersion = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *SetupRequestReader) ToStruct() *SetupRequest {
	if m == nil {
		return nil
	}
	res := &SetupRequest{}
	res.Version = m.GetVersion()

	return res
}

func (s *SetupRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type SetupRequest struct {
	Version	uint64	`json:"version,omitempty"`
}

func (s *SetupRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *SetupRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Version != 0 {
		res.AppendUint64(wireSetupRequest_Version, s.Version)
	}
}

func (s *SetupRequest) Copy() *SetupRequest {
	if s == nil {
		return nil
	}
	res := &SetupRequest{}
	res.Version = s.Version

	return res
}

func (s *SetupRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Version != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireSetupRequest_Version) + gremlin.SizeUint64(s.Version)
		size += entrySize
	}

	return size
}

const (
	wireSetupResponse_Version gremlin.ProtoWireNumber = 1
	wireSetupResponse_InstanceIdBytes gremlin.ProtoWireNumber = 2
	wireSetupResponse_InstanceId gremlin.ProtoWireNumber = 3
)

type SetupResponseReader struct {
	buf *gremlin.Reader

	dataVersion     uint64
	dataInstanceIdBytes     []byte
	dataInstanceId     string

	offsetVersion   int
	offsetInstanceIdBytes   int
	offsetInstanceId   int

	parsedVersion   bool
	parsedInstanceIdBytes   bool
	parsedInstanceId   bool
}

func NewSetupResponseReader() *SetupResponseReader {
	return &SetupResponseReader{}
}

func (m *SetupResponseReader) GetVersion() uint64 {
	if m == nil {
		return 0
	}
	return m.readVersion()
}

func (m *SetupResponseReader) readVersion() uint64 {
	if m.parsedVersion {
		return m.dataVersion
	}
	wOffset := m.offsetVersion
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataVersion = entry
	m.parsedVersion = true
	return entry
}

func (m *SetupResponseReader) GetInstanceIdBytes() []byte {
	if m == nil {
		return nil
	}
	return m.readInstanceIdBytes()
}

func (m *SetupResponseReader) readInstanceIdBytes() []byte {
	if m.parsedInstanceIdBytes {
		return m.dataInstanceIdBytes
	}
	wOffset := m.offsetInstanceIdBytes
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataInstanceIdBytes = entry
	m.parsedInstanceIdBytes = true
	return entry
}

func (m *SetupResponseReader) GetInstanceId() string {
	if m == nil {
		return ""
	}
	return m.readInstanceId()
}

func (m *SetupResponseReader) readInstanceId() string {
	if m.parsedInstanceId {
		return m.dataInstanceId
	}
	wOffset := m.offsetInstanceId
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataInstanceId = entry
	m.parsedInstanceId = true
	return entry
}

func (m *SetupResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireSetupResponse_Version:
			m.offsetVersion = offset
		case wireSetupResponse_InstanceIdBytes:
			m.offsetInstanceIdBytes = offset
		case wireSetupResponse_InstanceId:
			m.offsetInstanceId = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *SetupResponseReader) ToStruct() *SetupResponse {
	if m == nil {
		return nil
	}
	res := &SetupResponse{}
	res.Version = m.GetVersion()
	res.InstanceIdBytes = m.GetInstanceIdBytes()
	res.InstanceId = m.GetInstanceId()

	return res
}

func (s *SetupResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type SetupResponse struct {
	Version	uint64	`json:"version,omitempty"`
	InstanceIdBytes	[]byte	`json:"instance_id_bytes,omitempty"`
	InstanceId	string	`json:"instance_id,omitempty"`
}

func (s *SetupResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *SetupResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Version != 0 {
		res.AppendUint64(wireSetupResponse_Version, s.Version)
	}
	if len(s.InstanceIdBytes) != 0 {
		res.AppendBytes(wireSetupResponse_InstanceIdBytes, s.InstanceIdBytes)
	}
	if s.InstanceId != "" {
		res.AppendString(wireSetupResponse_InstanceId, s.InstanceId)
	}
}

func (s *SetupResponse) Copy() *SetupResponse {
	if s == nil {
		return nil
	}
	res := &SetupResponse{}
	res.Version = s.Version
	res.InstanceIdBytes = s.InstanceIdBytes
	res.InstanceId = s.InstanceId

	return res
}

func (s *SetupResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Version != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireSetupResponse_Version) + gremlin.SizeUint64(s.Version)
		size += entrySize
	}

	if len(s.InstanceIdBytes) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.InstanceIdBytes)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireSetupResponse_InstanceIdBytes)
		size += entrySize
	}

	if s.InstanceId != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.InstanceId)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireSetupResponse_InstanceId)
		size += entrySize
	}

	return size
}

const (
	wirePingRequest_Sequence gremlin.ProtoWireNumber = 1
	wirePingRequest_ClientTimestampNs gremlin.ProtoWireNumber = 2
)

type PingRequestReader struct {
	buf *gremlin.Reader

	dataSequence     uint64
	dataClientTimestampNs     uint64

	offsetSequence   int
	offsetClientTimestampNs   int

	parsedSequence   bool
	parsedClientTimestampNs   bool
}

func NewPingRequestReader() *PingRequestReader {
	return &PingRequestReader{}
}

func (m *PingRequestReader) GetSequence() uint64 {
	if m == nil {
		return 0
	}
	return m.readSequence()
}

func (m *PingRequestReader) readSequence() uint64 {
	if m.parsedSequence {
		return m.dataSequence
	}
	wOffset := m.offsetSequence
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataSequence = entry
	m.parsedSequence = true
	return entry
}

func (m *PingRequestReader) GetClientTimestampNs() uint64 {
	if m == nil {
		return 0
	}
	return m.readClientTimestampNs()
}

func (m *PingRequestReader) readClientTimestampNs() uint64 {
	if m.parsedClientTimestampNs {
		return m.dataClientTimestampNs
	}
	wOffset := m.offsetClientTimestampNs
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataClientTimestampNs = entry
	m.parsedClientTimestampNs = true
	return entry
}

func (m *PingRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wirePingRequest_Sequence:
			m.offsetSequence = offset
		case wirePingRequest_ClientTimestampNs:
			m.offsetClientTimestampNs = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *PingRequestReader) ToStruct() *PingRequest {
	if m == nil {
		return nil
	}
	res := &PingRequest{}
	res.Sequence = m.GetSequence()
	res.ClientTimestampNs = m.GetClientTimestampNs()

	return res
}

func (s *PingRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type PingRequest struct {
	Sequence	uint64	`json:"sequence,omitempty"`
	ClientTimestampNs	uint64	`json:"client_timestamp_ns,omitempty"`
}

func (s *PingRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *PingRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.Sequence != 0 {
		res.AppendUint64(wirePingRequest_Sequence, s.Sequence)
	}
	if s.ClientTimestampNs != 0 {
		res.AppendUint64(wirePingRequest_ClientTimestampNs, s.ClientTimestampNs)
	}
}

func (s *PingRequest) Copy() *PingRequest {
	if s == nil {
		return nil
	}
	res := &PingRequest{}
	res.Sequence = s.Sequence
	res.ClientTimestampNs = s.ClientTimestampNs

	return res
}

func (s *PingRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.Sequence != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wirePingRequest_Sequence) + gremlin.SizeUint64(s.Sequence)
		size += entrySize
	}

	if s.ClientTimestampNs != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wirePingRequest_ClientTimestampNs) + gremlin.SizeUint64(s.ClientTimestampNs)
		size += entrySize
	}

	return size
}

const (
	wirePingResponse_LocalStampNs gremlin.ProtoWireNumber = 2
	wirePingResponse_MonotonicStampNs gremlin.ProtoWireNumber = 3
	wirePingResponse_Request gremlin.ProtoWireNumber = 4
)

type PingResponseReader struct {
	buf *gremlin.Reader

	dataLocalStampNs     uint64
	dataMonotonicStampNs     uint64
	dataRequest     *PingRequestReader

	offsetLocalStampNs   int
	offsetMonotonicStampNs   int
	offsetRequest   int

	parsedLocalStampNs   bool
	parsedMonotonicStampNs   bool
	parsedRequest   bool
}

func NewPingResponseReader() *PingResponseReader {
	return &PingResponseReader{}
}

func (m *PingResponseReader) GetLocalStampNs() uint64 {
	if m == nil {
		return 0
	}
	return m.readLocalStampNs()
}

func (m *PingResponseReader) readLocalStampNs() uint64 {
	if m.parsedLocalStampNs {
		return m.dataLocalStampNs
	}
	wOffset := m.offsetLocalStampNs
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataLocalStampNs = entry
	m.parsedLocalStampNs = true
	return entry
}

func (m *PingResponseReader) GetMonotonicStampNs() uint64 {
	if m == nil {
		return 0
	}
	return m.readMonotonicStampNs()
}

func (m *PingResponseReader) readMonotonicStampNs() uint64 {
	if m.parsedMonotonicStampNs {
		return m.dataMonotonicStampNs
	}
	wOffset := m.offsetMonotonicStampNs
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataMonotonicStampNs = entry
	m.parsedMonotonicStampNs = true
	return entry
}

func (m *PingResponseReader) GetRequest() *PingRequestReader {
	if m == nil {
		return nil
	}
	return m.readRequest()
}

func (m *PingResponseReader) readRequest() *PingRequestReader {
	if m.parsedRequest {
		return m.dataRequest
	}
	wOffset := m.offsetRequest
	
	var entry *PingRequestReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewPingRequestReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataRequest = entry
	m.parsedRequest = true
	return entry
}

func (m *PingResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wirePingResponse_LocalStampNs:
			m.offsetLocalStampNs = offset
		case wirePingResponse_MonotonicStampNs:
			m.offsetMonotonicStampNs = offset
		case wirePingResponse_Request:
			m.offsetRequest = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *PingResponseReader) ToStruct() *PingResponse {
	if m == nil {
		return nil
	}
	res := &PingResponse{}
	res.LocalStampNs = m.GetLocalStampNs()
	res.MonotonicStampNs = m.GetMonotonicStampNs()

	{
		var data = m.GetRequest()
		var structData *PingRequest
		if data != nil {
			structData = data.ToStruct()
		}
		res.Request = structData
	}

	return res
}

func (s *PingResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type PingResponse struct {
	LocalStampNs	uint64	`json:"local_stamp_ns,omitempty"`
	MonotonicStampNs	uint64	`json:"monotonic_stamp_ns,omitempty"`
	Request	*PingRequest	`json:"request,omitempty"`
}

func (s *PingResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *PingResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.LocalStampNs != 0 {
		res.AppendUint64(wirePingResponse_LocalStampNs, s.LocalStampNs)
	}
	if s.MonotonicStampNs != 0 {
		res.AppendUint64(wirePingResponse_MonotonicStampNs, s.MonotonicStampNs)
	}
	if s.Request != nil {
		structSize := s.Request.XXX_PbContentSize()
		res.AppendBytesTag(wirePingResponse_Request, structSize)
		s.Request.MarshalTo(res)
	}
}

func (s *PingResponse) Copy() *PingResponse {
	if s == nil {
		return nil
	}
	res := &PingResponse{}
	res.LocalStampNs = s.LocalStampNs
	res.MonotonicStampNs = s.MonotonicStampNs
	if s.Request != nil {
		res.Request = s.Request.Copy()
	}

	return res
}

func (s *PingResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.LocalStampNs != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wirePingResponse_LocalStampNs) + gremlin.SizeUint64(s.LocalStampNs)
		size += entrySize
	}

	if s.MonotonicStampNs != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wirePingResponse_MonotonicStampNs) + gremlin.SizeUint64(s.MonotonicStampNs)
		size += entrySize
	}

	if s.Request != nil {
		var entrySize = 0
		entrySize = s.Request.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wirePingResponse_Request)
		
		size += entrySize
	}

	return size
}

const (
	wireWriteRequest_WriteId gremlin.ProtoWireNumber = 1
	wireWriteRequest_QueueId gremlin.ProtoWireNumber = 2
	wireWriteRequest_Packets gremlin.ProtoWireNumber = 10
)

type WriteRequestReader struct {
	buf *gremlin.Reader

	dataWriteId     uint64
	dataQueueId     string
	dataPackets     [][]byte

	offsetWriteId   int
	offsetQueueId   int
	offsetPackets   []int

	parsedWriteId   bool
	parsedQueueId   bool
	parsedPackets   bool
}

func NewWriteRequestReader() *WriteRequestReader {
	return &WriteRequestReader{}
}

func (m *WriteRequestReader) GetWriteId() uint64 {
	if m == nil {
		return 0
	}
	return m.readWriteId()
}

func (m *WriteRequestReader) readWriteId() uint64 {
	if m.parsedWriteId {
		return m.dataWriteId
	}
	wOffset := m.offsetWriteId
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataWriteId = entry
	m.parsedWriteId = true
	return entry
}

func (m *WriteRequestReader) GetQueueId() string {
	if m == nil {
		return ""
	}
	return m.readQueueId()
}

func (m *WriteRequestReader) readQueueId() string {
	if m.parsedQueueId {
		return m.dataQueueId
	}
	wOffset := m.offsetQueueId
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataQueueId = entry
	m.parsedQueueId = true
	return entry
}

func (m *WriteRequestReader) GetPackets() [][]byte {
	if m == nil {
		return nil
	}
	return m.readPackets()
}

func (m *WriteRequestReader) readPackets() [][]byte {
	if m.parsedPackets {
		return m.dataPackets
	}
	wOffset := m.offsetPackets
	
	var entry [][]byte
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry []byte
		if wOffset > 0 {
			listEntry = m.buf.ReadBytes(wOffset)
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataPackets = entry
	m.parsedPackets = true
	return entry
}

func (m *WriteRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireWriteRequest_WriteId:
			m.offsetWriteId = offset
		case wireWriteRequest_QueueId:
			m.offsetQueueId = offset
		case wireWriteRequest_Packets:
			m.offsetPackets = append(m.offsetPackets, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *WriteRequestReader) ToStruct() *WriteRequest {
	if m == nil {
		return nil
	}
	res := &WriteRequest{}
	res.WriteId = m.GetWriteId()
	res.QueueId = m.GetQueueId()
	res.Packets = m.GetPackets()

	return res
}

func (s *WriteRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type WriteRequest struct {
	WriteId	uint64	`json:"write_id,omitempty"`
	QueueId	string	`json:"queue_id,omitempty"`
	Packets	[][]byte	`json:"packets,omitempty"`
}

func (s *WriteRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *WriteRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.WriteId != 0 {
		res.AppendUint64(wireWriteRequest_WriteId, s.WriteId)
	}
	if s.QueueId != "" {
		res.AppendString(wireWriteRequest_QueueId, s.QueueId)
	}
	if len(s.Packets) > 0 {
		for _, entry := range s.Packets {
			res.AppendBytes(wireWriteRequest_Packets, entry)
		}
	}
}

func (s *WriteRequest) Copy() *WriteRequest {
	if s == nil {
		return nil
	}
	res := &WriteRequest{}
	res.WriteId = s.WriteId
	res.QueueId = s.QueueId
	res.Packets = s.Packets

	return res
}

func (s *WriteRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.WriteId != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireWriteRequest_WriteId) + gremlin.SizeUint64(s.WriteId)
		size += entrySize
	}

	if s.QueueId != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.QueueId)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireWriteRequest_QueueId)
		size += entrySize
	}

	if len(s.Packets) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Packets {
			var listEntrySize int
			listEntrySize = gremlin.SizeBytes(val)
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireWriteRequest_Packets)
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireWriteResponse_WriteId gremlin.ProtoWireNumber = 1
	wireWriteResponse_Result gremlin.ProtoWireNumber = 2
	wireWriteResponse_Ids gremlin.ProtoWireNumber = 10
)

type WriteResponseReader struct {
	buf *gremlin.Reader

	dataWriteId     uint64
	dataResult     WriteResponse_Result
	dataIds     []*IdReader

	offsetWriteId   int
	offsetResult   int
	offsetIds   []int

	parsedWriteId   bool
	parsedResult   bool
	parsedIds   bool
}

func NewWriteResponseReader() *WriteResponseReader {
	return &WriteResponseReader{}
}

func (m *WriteResponseReader) GetWriteId() uint64 {
	if m == nil {
		return 0
	}
	return m.readWriteId()
}

func (m *WriteResponseReader) readWriteId() uint64 {
	if m.parsedWriteId {
		return m.dataWriteId
	}
	wOffset := m.offsetWriteId
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataWriteId = entry
	m.parsedWriteId = true
	return entry
}

func (m *WriteResponseReader) GetResult() WriteResponse_Result {
	if m == nil {
		return 0
	}
	return m.readResult()
}

func (m *WriteResponseReader) readResult() WriteResponse_Result {
	if m.parsedResult {
		return m.dataResult
	}
	wOffset := m.offsetResult
	
	var entry WriteResponse_Result
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = WriteResponse_Result(rawEntry)
	}
	
	m.dataResult = entry
	m.parsedResult = true
	return entry
}

func (m *WriteResponseReader) GetIds() []*IdReader {
	if m == nil {
		return nil
	}
	return m.readIds()
}

func (m *WriteResponseReader) readIds() []*IdReader {
	if m.parsedIds {
		return m.dataIds
	}
	wOffset := m.offsetIds
	
	var entry []*IdReader
	for i := 0; i < len(wOffset); i++ {
		wOffset := wOffset[i]
		
		var listEntry *IdReader
		if wOffset > 0 {
			var listEntryData = m.buf.ReadBytes(wOffset)
			if len(listEntryData) > 0 {
				listEntry = NewIdReader()
				listEntry.Unmarshal(listEntryData)
			}
		}
		
		entry = append(entry, listEntry)
	}
	
	m.dataIds = entry
	m.parsedIds = true
	return entry
}

func (m *WriteResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireWriteResponse_WriteId:
			m.offsetWriteId = offset
		case wireWriteResponse_Result:
			m.offsetResult = offset
		case wireWriteResponse_Ids:
			m.offsetIds = append(m.offsetIds, offset)
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *WriteResponseReader) ToStruct() *WriteResponse {
	if m == nil {
		return nil
	}
	res := &WriteResponse{}
	res.WriteId = m.GetWriteId()
	res.Result = m.GetResult()

	{
		var data = m.GetIds()
		var structData []*Id
		if len(data) > 0 {
			structData = make([]*Id, len(data))
			for i := range data {
				if data[i] != nil {
					structData[i] = data[i].ToStruct()
				}
			}
		}
		res.Ids = structData
	}

	return res
}

func (s *WriteResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type WriteResponse struct {
	WriteId	uint64	`json:"write_id,omitempty"`
	Result	WriteResponse_Result	`json:"result,omitempty"`
	Ids	[]*Id	`json:"ids,omitempty"`
}

func (s *WriteResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *WriteResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.WriteId != 0 {
		res.AppendUint64(wireWriteResponse_WriteId, s.WriteId)
	}
	if s.Result != 0 {
		res.AppendInt32(wireWriteResponse_Result, int32(s.Result))
	}
	if len(s.Ids) > 0 {
		for _, entry := range s.Ids {
			structSize := entry.XXX_PbContentSize()
			res.AppendBytesTag(wireWriteResponse_Ids, structSize)
			entry.MarshalTo(res)
		}
	}
}

func (s *WriteResponse) Copy() *WriteResponse {
	if s == nil {
		return nil
	}
	res := &WriteResponse{}
	res.WriteId = s.WriteId
	res.Result = s.Result
	res.Ids = make([]*Id, len(s.Ids))
	for i := range s.Ids {
		if s.Ids[i] != nil {
			res.Ids[i] = s.Ids[i].Copy()
		}
	}

	return res
}

func (s *WriteResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.WriteId != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireWriteResponse_WriteId) + gremlin.SizeUint64(s.WriteId)
		size += entrySize
	}

	if s.Result != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireWriteResponse_Result) + gremlin.SizeInt32(int32(s.Result))
		size += entrySize
	}

	if len(s.Ids) > 0 {
		var entrySize = 0
		entrySize = 0
		for _, val := range s.Ids {
			var listEntrySize int
			listEntrySize = val.XXX_PbContentSize()
			listEntrySize += gremlin.SizeUint64(uint64(listEntrySize)) + gremlin.SizeTag(wireWriteResponse_Ids)
			
			entrySize += listEntrySize
		}
		size += entrySize
	}

	return size
}

const (
	wireReadRequest_ReadId gremlin.ProtoWireNumber = 1
	wireReadRequest_QueueId gremlin.ProtoWireNumber = 2
	wireReadRequest_Step gremlin.ProtoWireNumber = 3
	wireReadRequest_Offset gremlin.ProtoWireNumber = 10
	wireReadRequest_Limit gremlin.ProtoWireNumber = 11
)

type ReadRequestReader struct {
	buf *gremlin.Reader

	dataReadId     uint64
	dataQueueId     string
	dataStep     uint64
	dataOffset     *OffsetReader
	dataLimit     uint64

	offsetReadId   int
	offsetQueueId   int
	offsetStep   int
	offsetOffset   int
	offsetLimit   int

	parsedReadId   bool
	parsedQueueId   bool
	parsedStep   bool
	parsedOffset   bool
	parsedLimit   bool
}

func NewReadRequestReader() *ReadRequestReader {
	return &ReadRequestReader{}
}

func (m *ReadRequestReader) GetReadId() uint64 {
	if m == nil {
		return 0
	}
	return m.readReadId()
}

func (m *ReadRequestReader) readReadId() uint64 {
	if m.parsedReadId {
		return m.dataReadId
	}
	wOffset := m.offsetReadId
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataReadId = entry
	m.parsedReadId = true
	return entry
}

func (m *ReadRequestReader) GetQueueId() string {
	if m == nil {
		return ""
	}
	return m.readQueueId()
}

func (m *ReadRequestReader) readQueueId() string {
	if m.parsedQueueId {
		return m.dataQueueId
	}
	wOffset := m.offsetQueueId
	
	var entry string
	if wOffset > 0 {
		entry = m.buf.ReadString(wOffset)
	}
	
	m.dataQueueId = entry
	m.parsedQueueId = true
	return entry
}

func (m *ReadRequestReader) GetStep() uint64 {
	if m == nil {
		return 0
	}
	return m.readStep()
}

func (m *ReadRequestReader) readStep() uint64 {
	if m.parsedStep {
		return m.dataStep
	}
	wOffset := m.offsetStep
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataStep = entry
	m.parsedStep = true
	return entry
}

func (m *ReadRequestReader) GetOffset() *OffsetReader {
	if m == nil {
		return nil
	}
	return m.readOffset()
}

func (m *ReadRequestReader) readOffset() *OffsetReader {
	if m.parsedOffset {
		return m.dataOffset
	}
	wOffset := m.offsetOffset
	
	var entry *OffsetReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewOffsetReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataOffset = entry
	m.parsedOffset = true
	return entry
}

func (m *ReadRequestReader) GetLimit() uint64 {
	if m == nil {
		return 0
	}
	return m.readLimit()
}

func (m *ReadRequestReader) readLimit() uint64 {
	if m.parsedLimit {
		return m.dataLimit
	}
	wOffset := m.offsetLimit
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataLimit = entry
	m.parsedLimit = true
	return entry
}

func (m *ReadRequestReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireReadRequest_ReadId:
			m.offsetReadId = offset
		case wireReadRequest_QueueId:
			m.offsetQueueId = offset
		case wireReadRequest_Step:
			m.offsetStep = offset
		case wireReadRequest_Offset:
			m.offsetOffset = offset
		case wireReadRequest_Limit:
			m.offsetLimit = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ReadRequestReader) ToStruct() *ReadRequest {
	if m == nil {
		return nil
	}
	res := &ReadRequest{}
	res.ReadId = m.GetReadId()
	res.QueueId = m.GetQueueId()
	res.Step = m.GetStep()

	{
		var data = m.GetOffset()
		var structData *Offset
		if data != nil {
			structData = data.ToStruct()
		}
		res.Offset = structData
	}
	res.Limit = m.GetLimit()

	return res
}

func (s *ReadRequestReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ReadRequest struct {
	ReadId	uint64	`json:"read_id,omitempty"`
	QueueId	string	`json:"queue_id,omitempty"`
	Step	uint64	`json:"step,omitempty"`
	Offset	*Offset	`json:"offset,omitempty"`
	Limit	uint64	`json:"limit,omitempty"`
}

func (s *ReadRequest) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ReadRequest) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.ReadId != 0 {
		res.AppendUint64(wireReadRequest_ReadId, s.ReadId)
	}
	if s.QueueId != "" {
		res.AppendString(wireReadRequest_QueueId, s.QueueId)
	}
	if s.Step != 0 {
		res.AppendUint64(wireReadRequest_Step, s.Step)
	}
	if s.Offset != nil {
		structSize := s.Offset.XXX_PbContentSize()
		res.AppendBytesTag(wireReadRequest_Offset, structSize)
		s.Offset.MarshalTo(res)
	}
	if s.Limit != 0 {
		res.AppendUint64(wireReadRequest_Limit, s.Limit)
	}
}

func (s *ReadRequest) Copy() *ReadRequest {
	if s == nil {
		return nil
	}
	res := &ReadRequest{}
	res.ReadId = s.ReadId
	res.QueueId = s.QueueId
	res.Step = s.Step
	if s.Offset != nil {
		res.Offset = s.Offset.Copy()
	}
	res.Limit = s.Limit

	return res
}

func (s *ReadRequest) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.ReadId != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireReadRequest_ReadId) + gremlin.SizeUint64(s.ReadId)
		size += entrySize
	}

	if s.QueueId != "" {
		var entrySize = 0
		entrySize = gremlin.SizeString(s.QueueId)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireReadRequest_QueueId)
		size += entrySize
	}

	if s.Step != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireReadRequest_Step) + gremlin.SizeUint64(s.Step)
		size += entrySize
	}

	if s.Offset != nil {
		var entrySize = 0
		entrySize = s.Offset.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireReadRequest_Offset)
		
		size += entrySize
	}

	if s.Limit != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireReadRequest_Limit) + gremlin.SizeUint64(s.Limit)
		size += entrySize
	}

	return size
}

const (
	wireReadResponse_ReadId gremlin.ProtoWireNumber = 1
	wireReadResponse_Result gremlin.ProtoWireNumber = 2
	wireReadResponse_Id gremlin.ProtoWireNumber = 10
	wireReadResponse_Data gremlin.ProtoWireNumber = 11
	wireReadResponse_DataSource gremlin.ProtoWireNumber = 12
)

type ReadResponseReader struct {
	buf *gremlin.Reader

	dataReadId     uint64
	dataResult     ReadResponse_Result
	dataId     *IdReader
	dataData     []byte
	dataDataSource     ReadResponse_DataSource

	offsetReadId   int
	offsetResult   int
	offsetId   int
	offsetData   int
	offsetDataSource   int

	parsedReadId   bool
	parsedResult   bool
	parsedId   bool
	parsedData   bool
	parsedDataSource   bool
}

func NewReadResponseReader() *ReadResponseReader {
	return &ReadResponseReader{}
}

func (m *ReadResponseReader) GetReadId() uint64 {
	if m == nil {
		return 0
	}
	return m.readReadId()
}

func (m *ReadResponseReader) readReadId() uint64 {
	if m.parsedReadId {
		return m.dataReadId
	}
	wOffset := m.offsetReadId
	
	var entry uint64
	if wOffset > 0 {
		entry = m.buf.ReadUint64(wOffset)
	}
	
	m.dataReadId = entry
	m.parsedReadId = true
	return entry
}

func (m *ReadResponseReader) GetResult() ReadResponse_Result {
	if m == nil {
		return 0
	}
	return m.readResult()
}

func (m *ReadResponseReader) readResult() ReadResponse_Result {
	if m.parsedResult {
		return m.dataResult
	}
	wOffset := m.offsetResult
	
	var entry ReadResponse_Result
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ReadResponse_Result(rawEntry)
	}
	
	m.dataResult = entry
	m.parsedResult = true
	return entry
}

func (m *ReadResponseReader) GetId() *IdReader {
	if m == nil {
		return nil
	}
	return m.readId()
}

func (m *ReadResponseReader) readId() *IdReader {
	if m.parsedId {
		return m.dataId
	}
	wOffset := m.offsetId
	
	var entry *IdReader
	if wOffset > 0 {
		var entryData = m.buf.ReadBytes(wOffset)
		if len(entryData) > 0 {
			entry = NewIdReader()
			entry.Unmarshal(entryData)
		}
	}
	
	m.dataId = entry
	m.parsedId = true
	return entry
}

func (m *ReadResponseReader) GetData() []byte {
	if m == nil {
		return nil
	}
	return m.readData()
}

func (m *ReadResponseReader) readData() []byte {
	if m.parsedData {
		return m.dataData
	}
	wOffset := m.offsetData
	
	var entry []byte
	if wOffset > 0 {
		entry = m.buf.ReadBytes(wOffset)
	}
	
	m.dataData = entry
	m.parsedData = true
	return entry
}

func (m *ReadResponseReader) GetDataSource() ReadResponse_DataSource {
	if m == nil {
		return 0
	}
	return m.readDataSource()
}

func (m *ReadResponseReader) readDataSource() ReadResponse_DataSource {
	if m.parsedDataSource {
		return m.dataDataSource
	}
	wOffset := m.offsetDataSource
	
	var entry ReadResponse_DataSource
	if wOffset > 0 {
		rawEntry := m.buf.ReadInt32(wOffset)
		entry = ReadResponse_DataSource(rawEntry)
	}
	
	m.dataDataSource = entry
	m.parsedDataSource = true
	return entry
}

func (m *ReadResponseReader) Unmarshal(data []byte) error {
	m.buf = gremlin.NewReader(data)
	offset := 0
	for m.buf.HasNext(offset, 0) {
		tag, wire, tagSize, err := m.buf.ReadTagAt(offset)
		if err != nil {
			return err
		}

		offset += tagSize
		switch tag {
		case wireReadResponse_ReadId:
			m.offsetReadId = offset
		case wireReadResponse_Result:
			m.offsetResult = offset
		case wireReadResponse_Id:
			m.offsetId = offset
		case wireReadResponse_Data:
			m.offsetData = offset
		case wireReadResponse_DataSource:
			m.offsetDataSource = offset
		}

		offset, err = m.buf.SkipData(offset, wire)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *ReadResponseReader) ToStruct() *ReadResponse {
	if m == nil {
		return nil
	}
	res := &ReadResponse{}
	res.ReadId = m.GetReadId()
	res.Result = m.GetResult()

	{
		var data = m.GetId()
		var structData *Id
		if data != nil {
			structData = data.ToStruct()
		}
		res.Id = structData
	}
	res.Data = m.GetData()
	res.DataSource = m.GetDataSource()

	return res
}

func (s *ReadResponseReader) SourceBytes() []byte {
	if s == nil {
		return nil
	}
	return s.buf.Bytes()
}

type ReadResponse struct {
	ReadId	uint64	`json:"read_id,omitempty"`
	Result	ReadResponse_Result	`json:"result,omitempty"`
	Id	*Id	`json:"id,omitempty"`
	Data	[]byte	`json:"data,omitempty"`
	DataSource	ReadResponse_DataSource	`json:"data_source,omitempty"`
}

func (s *ReadResponse) Marshal() []byte {
	if s == nil {
		return nil
	}
	size := s.XXX_PbContentSize()
	if size == 0 {
		return nil
	}
	res := gremlin.NewWriter(size)
	s.MarshalTo(res)
	return res.Bytes()
}

func (s *ReadResponse) MarshalTo(res *gremlin.Writer) {
	if s == nil {
		return
	}

	if s.ReadId != 0 {
		res.AppendUint64(wireReadResponse_ReadId, s.ReadId)
	}
	if s.Result != 0 {
		res.AppendInt32(wireReadResponse_Result, int32(s.Result))
	}
	if s.Id != nil {
		structSize := s.Id.XXX_PbContentSize()
		res.AppendBytesTag(wireReadResponse_Id, structSize)
		s.Id.MarshalTo(res)
	}
	if len(s.Data) != 0 {
		res.AppendBytes(wireReadResponse_Data, s.Data)
	}
	if s.DataSource != 0 {
		res.AppendInt32(wireReadResponse_DataSource, int32(s.DataSource))
	}
}

func (s *ReadResponse) Copy() *ReadResponse {
	if s == nil {
		return nil
	}
	res := &ReadResponse{}
	res.ReadId = s.ReadId
	res.Result = s.Result
	if s.Id != nil {
		res.Id = s.Id.Copy()
	}
	res.Data = s.Data
	res.DataSource = s.DataSource

	return res
}

func (s *ReadResponse) XXX_PbContentSize() int {
	if s == nil {
		return 0
	}
	var size = 0

	if s.ReadId != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireReadResponse_ReadId) + gremlin.SizeUint64(s.ReadId)
		size += entrySize
	}

	if s.Result != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireReadResponse_Result) + gremlin.SizeInt32(int32(s.Result))
		size += entrySize
	}

	if s.Id != nil {
		var entrySize = 0
		entrySize = s.Id.XXX_PbContentSize()
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireReadResponse_Id)
		
		size += entrySize
	}

	if len(s.Data) != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeBytes(s.Data)
		entrySize += gremlin.SizeUint64(uint64(entrySize)) + gremlin.SizeTag(wireReadResponse_Data)
		size += entrySize
	}

	if s.DataSource != 0 {
		var entrySize = 0
		entrySize = gremlin.SizeTag(wireReadResponse_DataSource) + gremlin.SizeInt32(int32(s.DataSource))
		size += entrySize
	}

	return size
}
