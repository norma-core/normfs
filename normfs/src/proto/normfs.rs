// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientRequest {
    #[prost(message, optional, tag = "1")]
    pub setup: ::core::option::Option<SetupRequest>,
    #[prost(message, optional, tag = "2")]
    pub ping: ::core::option::Option<PingRequest>,
    #[prost(message, optional, tag = "10")]
    pub write: ::core::option::Option<WriteRequest>,
    #[prost(message, optional, tag = "11")]
    pub read: ::core::option::Option<ReadRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerResponse {
    #[prost(message, optional, tag = "1")]
    pub setup: ::core::option::Option<SetupResponse>,
    #[prost(message, optional, tag = "2")]
    pub ping: ::core::option::Option<PingResponse>,
    #[prost(message, optional, tag = "10")]
    pub write: ::core::option::Option<WriteResponse>,
    #[prost(message, optional, tag = "11")]
    pub read: ::core::option::Option<ReadResponse>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Id {
    #[prost(bytes = "bytes", tag = "1")]
    pub raw: ::prost::bytes::Bytes,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Offset {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Id>,
    #[prost(enumeration = "OffsetType", tag = "2")]
    pub r#type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetupRequest {
    #[prost(uint64, tag = "1")]
    pub version: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetupResponse {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(bytes = "bytes", tag = "2")]
    pub instance_id_bytes: ::prost::bytes::Bytes,
    #[prost(string, tag = "3")]
    pub instance_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingRequest {
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    #[prost(uint64, tag = "2")]
    pub client_timestamp_ns: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingResponse {
    #[prost(uint64, tag = "2")]
    pub local_stamp_ns: u64,
    #[prost(uint64, tag = "3")]
    pub monotonic_stamp_ns: u64,
    #[prost(message, optional, tag = "4")]
    pub request: ::core::option::Option<PingRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(uint64, tag = "1")]
    pub write_id: u64,
    #[prost(string, tag = "2")]
    pub queue_id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", repeated, tag = "10")]
    pub packets: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResponse {
    #[prost(uint64, tag = "1")]
    pub write_id: u64,
    #[prost(enumeration = "write_response::Result", tag = "2")]
    pub result: i32,
    #[prost(message, repeated, tag = "10")]
    pub ids: ::prost::alloc::vec::Vec<Id>,
}
/// Nested message and enum types in `WriteResponse`.
pub mod write_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        WrDone = 0,
        WrServerError = 1,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::WrDone => "WR_DONE",
                Result::WrServerError => "WR_SERVER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WR_DONE" => Some(Self::WrDone),
                "WR_SERVER_ERROR" => Some(Self::WrServerError),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    #[prost(uint64, tag = "1")]
    pub read_id: u64,
    #[prost(string, tag = "2")]
    pub queue_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub step: u64,
    #[prost(message, optional, tag = "10")]
    pub offset: ::core::option::Option<Offset>,
    #[prost(uint64, tag = "11")]
    pub limit: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    #[prost(uint64, tag = "1")]
    pub read_id: u64,
    #[prost(enumeration = "read_response::Result", tag = "2")]
    pub result: i32,
    #[prost(message, optional, tag = "10")]
    pub id: ::core::option::Option<Id>,
    #[prost(bytes = "bytes", tag = "11")]
    pub data: ::prost::bytes::Bytes,
    #[prost(enumeration = "read_response::DataSource", tag = "12")]
    pub data_source: i32,
}
/// Nested message and enum types in `ReadResponse`.
pub mod read_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        RrStart = 0,
        RrEntry = 1,
        RrEnd = 2,
        RrQueueNotFound = 3,
        RrNotFound = 4,
        RrServerError = 5,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::RrStart => "RR_START",
                Result::RrEntry => "RR_ENTRY",
                Result::RrEnd => "RR_END",
                Result::RrQueueNotFound => "RR_QUEUE_NOT_FOUND",
                Result::RrNotFound => "RR_NOT_FOUND",
                Result::RrServerError => "RR_SERVER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RR_START" => Some(Self::RrStart),
                "RR_ENTRY" => Some(Self::RrEntry),
                "RR_END" => Some(Self::RrEnd),
                "RR_QUEUE_NOT_FOUND" => Some(Self::RrQueueNotFound),
                "RR_NOT_FOUND" => Some(Self::RrNotFound),
                "RR_SERVER_ERROR" => Some(Self::RrServerError),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataSource {
        DsNone = 0,
        DsCloud = 1,
        DsDiskStore = 2,
        DsDiskWal = 3,
        DsMemory = 4,
    }
    impl DataSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataSource::DsNone => "DS_NONE",
                DataSource::DsCloud => "DS_CLOUD",
                DataSource::DsDiskStore => "DS_DISK_STORE",
                DataSource::DsDiskWal => "DS_DISK_WAL",
                DataSource::DsMemory => "DS_MEMORY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DS_NONE" => Some(Self::DsNone),
                "DS_CLOUD" => Some(Self::DsCloud),
                "DS_DISK_STORE" => Some(Self::DsDiskStore),
                "DS_DISK_WAL" => Some(Self::DsDiskWal),
                "DS_MEMORY" => Some(Self::DsMemory),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OffsetType {
    OtAbsolute = 0,
    OtShiftFromTail = 1,
}
impl OffsetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OffsetType::OtAbsolute => "OT_ABSOLUTE",
            OffsetType::OtShiftFromTail => "OT_SHIFT_FROM_TAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OT_ABSOLUTE" => Some(Self::OtAbsolute),
            "OT_SHIFT_FROM_TAIL" => Some(Self::OtShiftFromTail),
            _ => None,
        }
    }
}
